<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BSRef - React</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,200;0,300;0,400;0,700;1,200;1,300;1,400;1,700&display=swap"
      rel="stylesheet" />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="../scripts/format-html.js" async></script>
    <link href="../styles/global.css" type="text/css" rel="stylesheet" />
  </head>
  <body>
    <header class="header">
      <nav class="nav">
        <a href="../" class="nav__button anchor--nostyle">
          <h2 class="nav__heading">BSRef</h2>
        </a>
      </nav>
    </header>
    <main class="main">
      <h1 class="main__heading">React</h1>
      <p class="main__description">
        React is a framework developed by Meta that's designed around creating complex web applications with highly
        dynamic content built around reusable UI components. See more on
        <a href="https://react.dev/" target="_blank">React's website here</a>.
      </p>
      <h2 class="main__subheading">Overview</h2>
      <ul class="notes">
        <li class="note">
          React is designed around components, which can be reused throughout a web application. At the time of writing,
          it's arguably the most popular front-end application on the web.
        </li>
        <li class="note">
          Next.js was built on React, and is a newer framework that takes React's features to the next level.
        </li>
        <li class="note">React is modular, and provides ways to unit test our UI more easily.</li>
        <li class="note">
          It's also flexible and fast, and conveniently, React can render on the server-side as well as the client-side.
        </li>
        <li class="note">
          Good tooling is available - like the <code>create-react-app</code> scaffolding, the React devtools chrome
          extension, and detailed error messages when something goes wrong.
        </li>
      </ul>
      <h2 class="main__subheading">Creating and Running a React App</h2>
      <ul class="notes">
        <li class="note">
          <a href="https://create-react-app.dev/" target="_blank">create-react-app</a> is a scaffolding tool available
          via npm to make setting up new React projects quickly and easily.
        </li>
        <li class="note">
          <a href="https://vitejs.dev/" target="_blank">Vite</a> is another way to create an environment, allowing for
          quick-start servers, live module replacement, and has gained popularity in recent years. This is an
          alternative to <code>create-react-app</code>.
        </li>
        <li class="note">
          Our React project will include a few folders and files essentially always: one is
          <strong>node_modules</strong>, one is <strong>public</strong> (which contains public front-end assets like a
          favicon), and one is <strong>src</strong>, which contains our front-end files.
        </li>
        <li class="note">
          Other files include <strong>package.json</strong>, which defines which packages are necessary for your app to
          run, <strong>package-lock.json</strong>, which works with package.json to ensure all developers working on the
          app are using the same versions of packages, and a readme.
        </li>
        <li class="note">To run an npm app, we can run <code>npm start</code> in the console.</li>
        <li class="note">
          App.js is a component that represents what we want to go into our React root. That root is defined inside
          index.js (by default according to create-react-app).
        </li>
      </ul>
      <h2 class="main__subheading">Components</h2>
      <ul class="notes">
        <li class="note">
          Components are the building blocks of any page in React - the first step of building a React application is
          chunking out bigger components into their smaller portions.
        </li>
        <li class="note">
          Component definitions are created in classes or functions, and have a capitalized first letter.
        </li>
        <li class="note">
          We instantiate a React "root" by defining where the application should reference and insert itself:
          <pre><code>const root = ReactDOM.createRoot(document.getElementById("root"));</code></pre>
        </li>
        <li class="note">
          Our components will often live in their own module, which will also have a capitalized file name. This will be
          the default export of the app.
        </li>
        <li class="note">
          Traditionally, React components used to only be allowed to store state when using class-based components. More
          recently, in 2019, a more functional approach has been supported by way of <strong>React Hooks</strong>, which
          let us access class-like state inside functional components. Since functional syntax allows us to write less
          code to accomplish the same task, this is generally the preferred method.
        </li>
        <li class="note">
          A React component must return only one parent element or wrapper. This can be a <code>div</code>, a
          <code>ul</code>, or any other html element, or it can be an empty wrapper called a
          <a href="https://react.dev/reference/react/Fragment" target="_blank">Fragment</a>. Elements in a fragment will
          behave as if they have no parent when added to the DOM.
        </li>
      </ul>
      <h2 class="main__subheading">JSX</h2>
      <ul class="notes">
        <li class="note">
          <a href="https://react.dev/learn/writing-markup-with-jsx" target="_blank">JSX</a> is a
          <strong>JavaScript Syntax Extension</strong> that allows us to write code in a way we wouldn't be allowed to
          with vanilla JavaScript. It looks like a templating language but has the full power of JavaScript available
          directly in the .js file.
        </li>
        <li class="note">
          We use JSX to write html-like syntax directly inside our JavaScript, which is then rendered/compiled as
          JavaScript by React and node.
        </li>
        <li class="note">
          To create a very simple component, our code inside a file like "MyComponent.js" might look something like
          this:
          <pre><code>function MyComponent() {
  return {
    &#60;div className="my-class">
      &#60;h1>Hello, World!&#60;/h1>
    &#60;/div>
  }
}</code></pre>
        </li>
        <li class="note">
          We can add HTML attributes directly to elements in JSX, but we have to adjust any that conflict with reserved
          JavaScript keyworrds. For example, <code>for</code> becomes <code>htmlFor</code>, and
          <code>class</code> becomes <code>className</code>.
        </li>
        <li class="note">
          We can mimic HTML attributes as
          <a href="https://react.dev/learn/passing-props-to-a-component" target="_blank"><strong>props</strong></a> by
          including the argument in our component inside curly braces (destructured). For example:
          <pre><code>export function MyComponent({ myProp }) {
    &#60;div className="my-class">
      &#60;h1>{ myProp }&#60;/h1>
    &#60;/div>
}</code></pre>
        </li>
        <li class="note">
          To subsequently render a component inside another component, we can first import the component we need, then
          use a self-closing html-like syntax to render an instance of that component.
          <pre><code>import { MyComponent } from "./MyComponent";
  
function MyOtherComponent() {
  return &#60;div class="my-other-class">
    &#60;MyComponent myProp="Hello, World!" />
  &#60;/div>
}
</code></pre>
        </li>
        <li class="note">
          When we "escape" into JavaScript, whatever's inside the escaped braces will only render if it reduces to
          either JSX or a string.
        </li>
      </ul>
      <h2 class="main__subheading">Virtual DOM</h2>
      <ul class="notes">
        <li class="note">
          React's <strong>Virtual DOM</strong> holds a representation of the DOM in memory at all times for us to
          modify, which allows us to only update the actual DOM once per modification.
        </li>
        <li class="note">
          The Virtual DOM is a tree of <code>ReactElement</code>s that hold the state of the DOM and allow for many
          changes to be made quickly without needing to modify the DOM each time a change is made.
        </li>
        <li class="note">
          The real DOM on the front-end of our app isn't updated except by <code>root.render()</code> in index.js.
        </li>
      </ul>
      <h2 class="main__subheading">Event Handlers</h2>
      <ul class="notes">
        <li class="note">
          Unlike in Vanilla JavaScript, we don't interact with the DOM directly. We let React handle the DOM for us, so
          event listeners have to be approached in a different way.
        </li>
        <li class="note">
          To register an event listener in JSX, we use the same events as in vanilla JavaScript, but they are camelCase
          and prefaced with <code>on</code>. For example:
          <pre><code>export const HiButton = () => {
  return (
    &#60;button onClick={(event => console.log(event.target))}>Hi!&#60;/button>
  );
}</code></pre>
        </li>
        <li class="note">
          To define this onClick property based on a behavior we pass from the parent, we can pass a function as a prop,
          just like we can with regular function parameters and event handlers. This lets us define one event handler to
          multiple different components, but allow those components do different things.
        </li>
        <li class="note">
          We can do this with any function to allow a child's behavior to change based on its parent.
        </li>
      </ul>
      <h2 class="main__subheading">Working With State</h2>
      <ul class="notes">
        <li class="note">
          <strong>State</strong> is the term we use in software engineering to refer to, literally, the current
          <strong>state</strong> of a program.
        </li>
        <li class="note">
          In React, data is managed and passed as capital-S
          <a href="https://react.dev/reference/react/useState" target="_blank"><strong>State</strong></a
          >, as well as
          <strong><a href="https://react.dev/learn/passing-props-to-a-component" target="_blank">Props</a></strong
          >.
        </li>
        <li class="note">
          We can pass data down to subcomponents using props, but we can't/shouldn't pass data up from a "child"
          component to its parent.
        </li>
        <li class="note">
          Props are always passed inside a single object, which is why we "destructure" them as they enter our
          components.
        </li>
        <li class="note">
          This is helpful - it means that we can use objects to add attributes to HTML elements, and it means we can add
          any type of data we want to an html-like syntax in our components.
        </li>
        <li class="note">Best practice is typically to use camelCase for our prop names.</li>
        <li class="note">
          In general, data and state information should flow downward, and not the other way around. But there are times
          where we also want to ensure the logic associated with grabbing data is "encapsulated" within a subcomponent,
          in which case we can use React's built-in state management to send new data to the state of our software.
        </li>
        <li class="note">
          Any time we generate a series of items from an array of data, we should give each dynamically generated
          element a unique <code>key</code>. Usually, this will come from a server or from the object supplying the
          data. This allows us to dynamically keep track of that component as our app is running and switch things
          around without struggling to keep things in the right order. This is one of the simplest ways to handle state
          within our app as it relates to dynamic data.
        </li>
        <li class="note">
          In React, any time the state of our site changes, it will automatically handle triggering DOM updates. This is
          the foundation React is built on, and what allows us to literally "react" to our stream of data.
        </li>
        <li class="note">
          To leverage this behavior, we can create special <strong>State variables</strong> - these will react in real
          time, and any prop that contains a state variable as a value somewhere will respond automatically any time
          that state variable changes.
        </li>
        <li class="note">
          Because modifying state is a side-effect, we need to explicitly import React's state management features
          through the use of <a href="https://react.dev/reference/react" target="_blank">hooks</a>. Probably the most
          common form of state management is done via the <code>useState()</code> react hook. To import the useState
          hook:
          <pre><code>import { useState } from "react";</code></pre>
        </li>
        <li class="note">
          To create a state variable, we use a destructuring syntax with useState, and pass the initial state value
          inside the method call. For example:
          <pre><code>const [value, setValue] = useState(0);</code></pre>
        </li>
        <li class="note">
          When we create a state variable, we are creating two things: the first is a variable (with any name) that can
          contain the state value, and the second is a "setter" that allows us to change the value of that state
          variable. We have to put useState (or any other state hook) inside of our Component function. Notice that
          setting the <code>value</code> we made above doesn't involve an <code>=</code>:
          <pre><code>setValue(value + 5);</code></pre>
        </li>
        <li class="note">
          We can also call setState with a callback function:
          <pre><code>setValue(currentValue => currentValue + 5);</code></pre>
        </li>
        <li class="note">
          When we want shared state to be modified by multiple components, we should move the state up to the nearest
          shared parent and pass down the value and/or a callback function the child component can call to set the
          value.
        </li>
        <li class="note">
          We should keep state as nested as possible, because only the components that use the state will rerender when
          it is updated. This can also help give a cue as to when something should be refactored into its own component
          (although this is not a rule, and components do not need to use state).
        </li>
      </ul>
      <h2 class="main__subheading">Effects, Async/Await, and Promises in React</h2>
      <ul class="notes">
        <li class="note">
          When working with external systems of any kind, React can start to get a little finicky. React handles a lot
          under the hood for us, but sometimes we want to - or have to - "escape" from the React world into vanilla
          JavaScript for one reason or another.
        </li>
        <li class="note">
          In React, we can't use <code>async/await</code> straight in our components like we normally would. This means
          that when we're fetching data that we need for rendering asynchronously, there will be some amount of time
          where that data won't be available yet.
        </li>
        <li class="note">
          Because of this, we need to <code>useState</code> to contain the result of our promises, and set that state to
          the result of our promise after its been awaited in an independent async function (which we
          <em>can</em> define inside our component). Our first idea might look something like this:
          <pre><code>import { useState } from "react";
import axios from "axios";

export function MyComponent() {
  const [data, setData] = useState(null);

  const getFromApi = async () => {
    const response = await axios.get("www.example-api.com/endpoint");
    setData(response.data);
  }

  getFromApi();

  return (
    &#60;>{data ? &#60;p>data.property&#60;/p> : &#60;p>Loading...&#60;/p>}&#60;/>
  );
}</code></pre>
        </li>
        <li class="note">
          The above example will kind of work, but there's a problem: this function is going to run on every re-render.
          This means that we're going to request our data hundreds of times, when really, we only need to make the
          request once.
        </li>
        <li class="note">
          To fix this, we need to
          <strong>explicitly tell React that this is a side effect, and let it know when it is allowed to run</strong>.
          <a href="https://react.dev/reference/react/useEffect" target="_blank">To do this</a>, we can use the
          <code>useEffect</code> hook.
        </li>
        <li class="note">
          <code>useEffect</code> is a <strong>React hook</strong> that takes a <strong>callback function</strong> as its
          first argument, and an array full of <strong>"dependencies"</strong> as its second argument.
        </li>
        <li class="note">
          The callback function will be called whenever anything in the dependency array changes between renders. For
          example, if the dependency array is an empty array, <code>useEffect</code> will only run its callback function
          once, when the component is first mounted.
          <pre><code>useEffect(() => console.log("I will only show up once!"), []);</code></pre>
        </li>
        <li class="note">
          This makes <code>useEffect</code> the <strong>go-to way to "escape" from the React paradigm</strong> - for
          example, to interact with vanilla JS APIs (including the DOM!), data fetched from an external API, or vanilla
          JS libraries and scripts.
        </li>
        <li class="note">
          If we don't give <code>useEffect</code> any dependencies, it will run any time state changes, which pretty
          much removes the utility of using effects in the first place - for this reason,
          <strong>we should pretty much always provide dependencies</strong>.
        </li>
        <li class="note">
          Putting all of this together, we can fix our earlier example using axios:
          <pre><code>import { useState, useEffect } from "react";
import axios from "axios";

export function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const getFromApi = async () => {
      const response = await axios.get("www.example-api.com/endpoint");
      setData(response.data);
    }
    getFromApi()
  }, []);

  return (
    &#60;>{data ? &#60;p>data.property&#60;/p> : &#60;p>Loading...&#60;/p>}&#60;/>
  );
}</code></pre>
        </li>
        <li class="note">
          Now, thanks to only fetching our data inside of <code>useEffect</code>, we will only ever fetch our data once
          - because our dependency array is empty, so there will never be anything to trigger an update again.
        </li>
        <li class="note">
          It's worth mentioning that there's no limits on how many dependencies we can add to a dependency array, which
          is the whole reason it's an array!
        </li>
        <li class="note">
          Something else to know about <code>useEffect</code> is that we can <code>return</code> a callback function
          that will run <strong>when the component is unmounted</strong>. This can be useful for cleaning up
          side-effects after you switch pages.
          <pre><code>import { useEffect } from "react";

export function WindowClickListener() {

  useEffect(() => {
    console.log("I'm an event listener that's needed when this component is on the page!");
    const sideEffectEventListener = () => console.log("I clicked something!");
    window.addEventListener("click", sideEffectEventListener);

    return () => {
      window.removeEventListener("click", sideEffectEventListener);
      console.log("I'm no longer needed, bye-bye!");
    }
  }, []);

  return (
    &#60;>Example of an effect with a window event listener&#60;/>
  );
}</code></pre>
        </li>
        <li class="note">
          The above example needs an event listener attached to the entire window whenever the component is mounted, but
          we shouldn't have that event listener if the component isn't present. For this reason, we return a callback
          that removes the event listener whenever the component is unmounted. This kind of effect is useful, because we
          don't just have a <code>Window</code> component somewhere where we can slap an <code>onClick</code> on it.
        </li>
        <li class="note">
          With async and await/promise functions, it's worth mentioning as well that React doesn't allow an effect do be
          defined with <code>async</code> the way normal event listeners might allow you to. For this reason, you
          usually have to create another async function inside the useEffect callback and then immediately call it.
        </li>
      </ul>
      <h2 class="main__subheading">useRef and Uncontrolled Components</h2>
      <ul class="notes">
        <li class="note">
          The <code>useRef</code> hook provides a way for us to access something outside the React paradigm, sort of
          like an effect, but instead of telling React what to do, we're just telling it where our side effects are
          coming from.
        </li>
        <li class="note">
          Interactions with the DOM, like using event.target, or giving an element in your JSX a
          <code>ref={refName}</code> prop, are typically examples of <strong>Uncontrolled Components</strong>. These are
          components that behave outside the declarative paradigm in some way.
        </li>
        <li class="note">
          There are times when refs are necessary, and they are still better than direct DOM manipulation when possible
          (since refs know about the shadow DOM), but in general, if a ref can be avoided, it should be. If they can't
          be avoided, it can also be a good idea to make a custom hook to abstract the imperative behavior out of your
          components.
        </li>
      </ul>
    </main>
  </body>
</html>
